use failure::Error;
use serde::{Deserialize, Serialize};
use serde_json::json;
use sha1;
use std::cell::Cell;
use std::collections::HashMap;
use std::fs;
use std::io::BufReader;
use std::path::PathBuf;
use std::string::String;
use uuid::Uuid;

#[derive(Serialize, Deserialize)]
struct CacheEntry {
    hash: String,     // sha1 hash of code block
    filename: String, // UUID4 generated filename for uniqueness
    #[serde(skip)]
    used: Cell<bool>, //Internal mutable state, unused items are discarded on save
}

pub struct Cache {
    entries: HashMap<String, CacheEntry>, // The key is generated by format_key function
    /// The directory where to store all the cache files
    cache_path: PathBuf,
}

/// Formats the key name by concatenating the chapter_path and code block index
fn format_key(chapter_path: &PathBuf, idx: u32) -> Option<String> {
    let chapter_path_str = chapter_path.to_str();
    if chapter_path_str.is_none() {
        return None;
    }

    Some(format!("{}_{}", chapter_path_str.unwrap(), idx))
}

impl Cache {
    /// Creates a Cache instance using the provided path. If the path does not
    /// exist it is created.
    /// When the path exists the cache entries are loaded from the cache file.
    /// # Arguments
    /// * `cache_path` - The path where the cache should be stored/loaded from, typically <book_root_dir>/.mdbook-plantuml-cache
    pub fn new(cache_path: &PathBuf) -> Result<Cache, Error> {
        let mut cache = Cache {
            entries: HashMap::new(),
            cache_path: cache_path.clone(),
        };

        if !cache_path.exists() {
            if let Err(e) = fs::create_dir_all(cache_path) {
                bail!(
                    "Failed to create cache directory '{}' ({}).",
                    cache_path.to_string_lossy(),
                    e
                );
            }
        } else {
            cache.load_cache();
        }

        Ok(cache)
    }

    fn load_cache(&mut self) {
        let cache_file = self.cache_file_path();

        match fs::File::open(&cache_file) {
            Err(e) => error!(
                "Failed to open cache file '{}' ({})",
                cache_file.to_string_lossy(),
                e
            ),
            Ok(f) => {
                let reader = BufReader::new(f);
                match serde_json::from_reader(reader) {
                    Err(e) => error!(
                        "Failed to parse cache file '{}' ({})",
                        cache_file.to_string_lossy(),
                        e
                    ),
                    Ok(entries) => {
                        self.entries = entries;
                        for (_key, entry) in &mut self.entries {
                            entry.used.set(false);
                        }
                    }
                }
            }
        }
    }

    fn cache_file_path(&self) -> PathBuf {
        let mut p = self.cache_path.clone();
        p.push("cache.json");
        p
    }

    /// Get the full path of the cached image, returns None if the file does not
    /// exist
    /// # Arguments
    /// * `filename` - The filename of the cached image file
    fn get_image_path(&self, filename: &String) -> Option<PathBuf> {
        let img_path = {
            let mut p = self.cache_path.clone();
            p.push(filename);
            p
        };

        if img_path.is_file() {
            return Some(img_path);
        }

        None
    }

    /// Returns the path to the cached image for the given code block, or None when the image is not cached, or the code
    /// has changed.
    ///
    /// # Arguments
    /// * `chapter_path` - The chapter path in the book (mdBook BookItem::Chapter::path value)
    /// * `idx` - A unique (chapter scope) index for the code block to get the cache for (there may be more than one code block in a single chapter)
    /// * `code_block_src` - The present source of the code block, if it does not match with the cached code block None is returned
    pub fn get_cached_image(
        &self,
        chapter_path: &PathBuf,
        idx: u32,
        code_block_src: &String,
    ) -> Option<PathBuf> {
        let key = format_key(chapter_path, idx);
        if key.is_none() {
            //TODO log error
            return None;
        }

        let expected_hash = sha1::Sha1::from(&code_block_src).hexdigest();
        if let Some(entry) = self.entries.get(&key.unwrap()) {
            if expected_hash == entry.hash {
                entry.used.set(true);
                return self.get_image_path(&entry.filename);
            }
        }

        None
    }

    /// Adds a new entry to the cache, or updates an existing one.
    /// # Arguments
    /// * `chapter_path` - The chapter path in the book (mdBook BookItem::Chapter::path value)
    /// * `idx` - A unique (chapter scope) index for the code block to get the cache for (there may be more than one code block in a single chapter)
    /// * `code_block_src` - The present source of the code block, if it does not match with the cached code block None is returned
    /// * `image_path` - The path to the image to cache (a copy of the file will be saved in the cache directory)
    fn add_entry(
        &mut self,
        chapter_path: &PathBuf,
        idx: u32,
        code_block_src: &String,
        image_path: &PathBuf,
    ) -> Result<(), Error> {
        let key = format_key(chapter_path, idx);
        if key.is_none() {
            bail!("Failed to format cache entry key");
        }

        let cache_filename = Uuid::new_v4().to_string();
        let cache_path = {
            let mut p = self.cache_path.clone();
            p.push(&cache_filename);
            p
        };
        if let Err(e) = fs::copy(image_path, cache_path) {
            bail!("Failed to copy source image file ({}).", e);
        }

        let hash = sha1::Sha1::from(code_block_src).hexdigest();
        self.entries.insert(
            key.unwrap(),
            CacheEntry {
                hash: hash,
                filename: cache_filename,
                used: Cell::new(true),
            },
        );

        Ok(())
    }
}

impl Drop for Cache {
    /// Save the cache to disk
    fn drop(&mut self) {
        let used_entries = {
            let mut entries: HashMap<String, CacheEntry> = HashMap::new();
            self.entries
                .iter()
                .filter(|&(_, v)| v.used.get())
                .map(|(k, v)| {
                    entries.insert(
                        k.clone(),
                        CacheEntry {
                            hash: v.hash.clone(),
                            filename: v.filename.clone(),
                            used: Cell::new(true),
                        },
                    )
                });
            entries
        };

        let cache_file = self.cache_file_path();
        if let Err(e) = fs::write(&cache_file, json!(used_entries).to_string()) {
            error!(
                "Failed to save cache to '{}' ({}).",
                cache_file.to_string_lossy(),
                e
            );
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;
    use std::fs;
    use tempfile::{tempdir, TempDir};

    struct TestContext {
        cached_image_dir: TempDir,
    }

    impl TestContext {
        fn new() -> TestContext {
            TestContext {
                cached_image_dir: tempdir().unwrap(),
            }
        }

        /// Create a cache bypassing the constructor
        fn create_cache(&self) -> Cache {
            Cache {
                cache_path: self.path_buf(),
                entries: HashMap::new(),
            }
        }

        fn path_buf(&self) -> PathBuf {
            self.cached_image_dir.path().to_path_buf()
        }

        fn create_cache_entry(
            &self,
            cache: &mut Cache,
            chapter: &PathBuf,
            idx: u32,
            code: &String,
        ) -> Result<(), Error> {
            //Create the source image file (this file is overwritten each time
            //create_cache_entry is called!)
            let test_img_path = self.test_img_path();
            assert!(fs::write(&test_img_path, code).is_ok());

            cache.add_entry(chapter, idx, code, &test_img_path)
        }

        fn test_img_path(&self) -> PathBuf {
            let mut p = self.path_buf();
            p.push("image.txt");
            p
        }
    }

    macro_rules! assert_is_cache_entry {
        ($ctx:expr,
            $cache: expr,
            $chapter: expr,
            $idx: expr,
            $code: expr) => {{
            let key = format_key($chapter, $idx).unwrap();
            assert!($cache.entries.contains_key(&key));

            let entry = $cache.entries.get(&key).unwrap();
            assert_eq!(entry.hash, sha1::Sha1::from($code).hexdigest());

            let cached_img_filename = {
                let mut p = $ctx.path_buf();
                p.push(&entry.filename);
                p
            };
            assert!(cached_img_filename.is_file());
            let cached_image_data = match fs::read(&cached_img_filename) {
                Ok(u8_data) => String::from(String::from_utf8_lossy(&u8_data)),
                Err(e) => format!("Failed to read cache image file ({})", e),
            };

            assert_eq!($code, &cached_image_data);
        }};
    }

    #[test]
    fn empty_cache_returns_none() {
        let ctx = TestContext::new();
        let cache = ctx.create_cache();
        assert!(cache
            .get_cached_image(&PathBuf::from("chapter"), 0, &String::from("some code"))
            .is_none())
    }

    #[test]
    fn format_key_concatenates_chapter_and_index() {
        assert_eq!("foo_1", format_key(&PathBuf::from("foo"), 1).unwrap());
        assert_eq!("bar_2", format_key(&PathBuf::from("bar"), 2).unwrap());
    }

    #[test]
    fn add_entry_fails_when_file_cannot_be_copied() {
        let ctx = TestContext::new();
        let mut cache = ctx.create_cache();

        //Add an entry with a non existing source file
        match cache.add_entry(
            &PathBuf::from("chapter"),
            1,
            &String::from("code block"),
            &PathBuf::from("nonexisting"),
        ) {
            Ok(_) => assert!(false, "Expected failure"),
            Err(_) => (),
        }
    }

    #[test]
    fn add_entry() {
        let ctx = TestContext::new();
        let mut cache = ctx.create_cache();

        match ctx.create_cache_entry(
            &mut cache,
            &PathBuf::from("chapter"),
            1,
            &String::from("code block"),
        ) {
            Ok(_) => (),
            Err(e) => assert!(false, format!("Expected success ({}).", e)),
        }

        assert_is_cache_entry!(
            &ctx,
            &cache,
            &PathBuf::from("chapter"),
            1,
            &String::from("code block")
        );
    }

    #[test]
    fn add_multiple_entries() {
        let ctx = TestContext::new();
        let mut cache = ctx.create_cache();

        assert!(ctx
            .create_cache_entry(
                &mut cache,
                &PathBuf::from("froboz"),
                1,
                &String::from("totemizer")
            )
            .is_ok());

        assert!(ctx
            .create_cache_entry(
                &mut cache,
                &PathBuf::from("electric"),
                2,
                &String::from("wizard repellant")
            )
            .is_ok());

        assert_is_cache_entry!(
            &ctx,
            &cache,
            &PathBuf::from("froboz"),
            1,
            &String::from("totemizer")
        );

        assert_is_cache_entry!(
            &ctx,
            &cache,
            &PathBuf::from("electric"),
            2,
            &String::from("wizard repellant")
        );
    }

    #[test]
    fn get_existing_entry() {
        let ctx = TestContext::new();
        let cache = {
            let mut cache = ctx.create_cache();

            assert!(ctx
                .create_cache_entry(
                    &mut cache,
                    &PathBuf::from("froboz"),
                    1,
                    &String::from("totemizer")
                )
                .is_ok());

            assert!(ctx
                .create_cache_entry(
                    &mut cache,
                    &PathBuf::from("electric"),
                    2,
                    &String::from("wizard repellant")
                )
                .is_ok());

            cache
        };

        let froboz_entry =
            cache.get_cached_image(&PathBuf::from("froboz"), 1, &String::from("totemizer"));
        assert!(froboz_entry.is_some());

        let electric_entry = cache.get_cached_image(
            &PathBuf::from("electric"),
            2,
            &String::from("wizard repellant"),
        );
        assert!(electric_entry.is_some());
    }

    #[test]
    fn get_uncached_entry() {
        let ctx = TestContext::new();
        let cache = {
            let mut cache = ctx.create_cache();

            assert!(ctx
                .create_cache_entry(
                    &mut cache,
                    &PathBuf::from("froboz"),
                    1,
                    &String::from("totemizer")
                )
                .is_ok());
            cache
        };

        assert!(cache
            .get_cached_image(
                &PathBuf::from("different chapter"),
                1,
                &String::from("totemizer")
            )
            .is_none());

        //Different index
        assert!(cache
            .get_cached_image(&PathBuf::from("froboz"), 9999, &String::from("totemizer"))
            .is_none());
    }

    #[test]
    fn get_with_changed_codeblock() {
        let ctx = TestContext::new();
        let cache = {
            let mut cache = ctx.create_cache();

            assert!(ctx
                .create_cache_entry(
                    &mut cache,
                    &PathBuf::from("froboz"),
                    1,
                    &String::from("totemizer")
                )
                .is_ok());
            cache
        };

        assert!(cache
            .get_cached_image(
                &PathBuf::from("froboz"),
                1,
                &String::from("changed code block")
            )
            .is_none());
    }

    #[test]
    fn get_with_missing_cached_image() {
        let ctx = TestContext::new();
        let cache = {
            let mut cache = ctx.create_cache();

            assert!(ctx
                .create_cache_entry(
                    &mut cache,
                    &PathBuf::from("froboz"),
                    1,
                    &String::from("totemizer")
                )
                .is_ok());
            cache
        };

        let cached_image_path =
            cache.get_cached_image(&PathBuf::from("froboz"), 1, &String::from("totemizer"));
        assert!(cached_image_path.is_some());

        //Delete the cached image, this should also yield None
        assert!(fs::remove_file(cached_image_path.unwrap()).is_ok());
        assert!(cache
            .get_cached_image(&PathBuf::from("froboz"), 1, &String::from("totemizer"))
            .is_none());
    }

    #[test]
    fn saves_cache_table_when_destroyed() {
        let ctx = TestContext::new();
        let expected_json;
        let cache_file;
        {
            let mut cache = ctx.create_cache();
            assert!(ctx
                .create_cache_entry(
                    &mut cache,
                    &PathBuf::from("froboz"),
                    1,
                    &String::from("totemizer")
                )
                .is_ok());

            assert!(ctx
                .create_cache_entry(
                    &mut cache,
                    &PathBuf::from("froboz"),
                    2,
                    &String::from("totemizer 2")
                )
                .is_ok());
            expected_json = json!(cache.entries).to_string();
            cache_file = cache.cache_file_path();
        }

        assert!(cache_file.is_file());
        let saved_cache_data = match fs::read(&cache_file) {
            Ok(u8_data) => String::from(String::from_utf8_lossy(&u8_data)),
            Err(e) => format!("Failed to read cache file ({})", e),
        };
        assert_eq!(expected_json, saved_cache_data);
    }

    #[test]
    fn loads_cache_table_when_created() {
        let ctx = TestContext::new();
        {
            //Create the cache (and save on drop when exiting this scope)
            let mut cache = ctx.create_cache();
            assert!(ctx
                .create_cache_entry(
                    &mut cache,
                    &PathBuf::from("froboz"),
                    1,
                    &String::from("totemizer")
                )
                .is_ok());
        }

        let cache = Cache::new(&ctx.path_buf());
        assert!(cache.is_ok());
        let cache = cache.unwrap();
        assert_is_cache_entry!(
            &ctx,
            &cache,
            &PathBuf::from("froboz"),
            1,
            &String::from("totemizer")
        );

        assert!(cache
            .get_cached_image(&PathBuf::from("froboz"), 1, &String::from("totemizer"))
            .is_some());
    }

    #[test]
    fn cache_dir_creation_failure_returns_error() {
        let ctx = TestContext::new();
        let invalid_dirname = {
            let mut p = ctx.path_buf();
            p.push("\0");
            p
        };

        let cache = Cache::new(&invalid_dirname);
        assert!(cache.is_err());
    }
}
